import os
import subprocess
from pathlib import Path
from openai import OpenAI
from dotenv import load_dotenv

# Import your prompt template
# Ensure this path is correct relative to where you run the script
from KunitGeneration.model_interface.prompts.unittest_kunit_prompts import kunit_generation_prompt


class KUnitTestGenerator:
    """
    A class to generate, compile, and validate KUnit tests for C functions.
    Automatically regenerates tests until compilation passes successfully.
    """

    def __init__(self, main_test_dir: Path, model_name: str, temperature: float, max_retries: int = 3):
        if not main_test_dir.is_dir():
            raise FileNotFoundError(f"The specified test directory does not exist: {main_test_dir}")

        # --- Paths ---
        self.base_dir = main_test_dir
        self.functions_dir = self.base_dir / "test_functions"
        self.output_dir = self.base_dir / "generated_tests"
        self.sample_files = [
            self.base_dir / "reference_testcases" / "kunit_test1.c",
            self.base_dir / "reference_testcases" / "kunit_test2.c",
            self.base_dir / "reference_testcases" / "kunit_test3.c",
        ]
        self.error_log_file = self.base_dir / "compilation_log" / "compile_error.txt"

        # --- Model ---
        self.model_name = model_name
        self.temperature = temperature
        self.max_tokens = 8192
        self.max_retries = max_retries

        # --- Setup ---
        self._load_environment()
        self.client = self._initialize_client()
        self.prompt_template = kunit_generation_prompt

    # ---------------- Environment Setup ----------------
    def _load_environment(self):
        load_dotenv()
        self.api_key = os.environ.get("NVIDIA_API_KEY")
        if not self.api_key:
            raise ValueError("NVIDIA_API_KEY environment variable not set.")

    def _initialize_client(self):
        return OpenAI(base_url="https://integrate.api.nvidia.com/v1", api_key=self.api_key)

    # ---------------- Model Query ----------------
    def _query_model(self, prompt: str) -> str:
        try:
            completion = self.client.chat.completions.create(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}],
                temperature=self.temperature,
                max_tokens=self.max_tokens,
            )
            response = completion.choices[0].message.content
            # Clean up model output from code fences
            return response.replace("```c", "").replace("```", "").strip()
        except Exception as e:
            print(f"An error occurred while querying the model: {e}")
            return f"// Error generating response: {e}"

    # ---------------- Context Loader ----------------
    def _load_context_files(self) -> dict:
        print("Reading sample KUnit test files and error logs...")
        context = {}
        def safe_read(p: Path, fallback="// Missing file"):
            return p.read_text(encoding="utf-8") if p.exists() else fallback

        context["sample_code1"] = safe_read(self.sample_files[0])
        context["sample_code2"] = safe_read(self.sample_files[1])
        context["sample_code3"] = safe_read(self.sample_files[2])
        context["error_logs"] = safe_read(self.error_log_file, "// No previous error logs")

        return context

    # ---------------- Kernel Build Integration ----------------
    def _update_makefile(self, test_name: str):
        # NOTE: This assumes the Makefile is in the same directory as the test functions.
        makefile_path = Path("/home/amd/linux/drivers/pinctrl/Makefile")
        if not makefile_path.exists():
            print(f"‚ö†Ô∏è  No Makefile found at '{makefile_path}' ‚Äî skipping Makefile update.")
            return
            
        config_name = test_name.upper()
        entry = f"obj-$(CONFIG_{config_name}) += {test_name}.o"
        text = makefile_path.read_text(encoding="utf-8")
        if entry not in text:
            with open(makefile_path, "a", encoding="utf-8") as f:
                f.write("\n" + entry + "\n")
            print(f"üß© Added to Makefile: {entry}")

    def _update_kconfig(self, test_name: str):
        """
        Ensures the main kernel Kconfig sources the custom test Kconfig file,
        and adds the specific config entry for the given test to that file.
        """
        # --- Part 1: Ensure the main kernel Kconfig sources our custom file ---
        main_kconfig_path = Path("/home/amd/linux/drivers/pinctrl/Kconfig")
        backup_path = main_kconfig_path.with_suffix(".KunitGen_backup")
        # This path assumes `my_pinctrl` is where your tests are located inside `drivers/pinctrl`
        new_source_line = 'source "drivers/pinctrl/my_pinctrl/Kconfig"'

        if not main_kconfig_path.exists():
            print(f"‚ùå Main Kconfig not found at {main_kconfig_path}")
            return False

        # Create backup if it doesn't exist
        if not backup_path.exists():
            backup_path.write_text(main_kconfig_path.read_text(encoding="utf-8"), encoding="utf-8")
            print(f"üì¶ Backup of main Kconfig created: {backup_path}")

        main_kconfig_text = main_kconfig_path.read_text(encoding="utf-8")

        custom_kconfig_path = self.base_dir / "Kconfig"
        config_name = test_name.upper()
        
        kconfig_entry = (
            f"\nconfig {config_name}\n"
            f'\tbool "KUnit test for {test_name}"\n'
            f"\tdepends on KUNIT\n"
            f"\tdefault n\n"
        )

        if not main_kconfig_path.exists():
            main_kconfig_path.write_text(kconfig_entry.strip(), encoding="utf-8")
            print(f"‚úÖ Created custom Kconfig and added entry for {config_name}")
        else:
            text = main_kconfig_path.read_text(encoding="utf-8")
            if f"config {config_name}" not in text:
            for line in lines:
                            if 'source "drivers/pinctrl/actions/Kconfig"' in line and not inserted:
                                    with open(main_kconfig_path, "a", encoding="utf-8") as f:
                                        f.write(kconfig_entry)
                                    print(f"üß© Added Kconfig entry for {config_name}")
            else:
                print(f"‚ÑπÔ∏è  Kconfig entry for {config_name} already exists.")
        
        return True

    def _update_test_config(self, test_name: str):
        cfg_path = Path("/home/amd/linux/my_pinctrl.config")
        if not cfg_path.exists():
            print(f"‚ö†Ô∏è  No my_pinctrl.config found at '{cfg_path}' ‚Äî skipping.")
            return
        config_line = f"CONFIG_{test_name.upper()}=m"
        cfg_text = cfg_path.read_text(encoding="utf-8")
        if config_line not in cfg_text:
            with open(cfg_path, "a", encoding="utf-8") as f:
                f.write("\n" + config_line + "\n")
            print(f"üß© Enabled {config_line} in my_pinctrl.config.")

    def _compile_and_check(self) -> bool:
        """Compile using the kernel's make command and check for errors."""
        print("‚öôÔ∏è  Running kernel build to check for compilation errors...")
        
        # NOTE: Hardcoded path to kernel source.
        kernel_dir = Path("/home/amd/linux")
        config_file = self.base_dir.parent / "my_pinctrl.config"
        cmd = (
            f"cp {config_file} {kernel_dir}/.config && "
            f"make -C {kernel_dir} olddefconfig && "
            f"make -C {kernel_dir} -k -j$(nproc)"
        )

        with open(self.error_log_file, "w", encoding="utf-8") as log_file:
             result = subprocess.run(cmd, shell=True, stdout=log_file, stderr=subprocess.STDOUT)

        log_text = self.error_log_file.read_text(encoding="utf-8")

        if "error:" in log_text.lower() or " undefined reference to" in log_text.lower():
            print(f"‚ùå Compilation failed. Check '{self.error_log_file.name}'.")
            return False
            
        print("‚úÖ Compilation successful.")
        return True

    # ---------------- Main Test Generation ----------------
    def generate_test_for_function(self, func_file_path: Path):
        func_code = func_file_path.read_text(encoding="utf-8")
        test_name = f"{func_file_path.stem}_kunit_test"
        out_file = self.output_dir / f"{test_name}.c"
        context = self._load_context_files()

        for attempt in range(1, self.max_retries + 1):
            print(f"\nüîπ Generating test for {func_file_path.name} (Attempt {attempt}/{self.max_retries})...")

            final_prompt = self.prompt_template.format(func_code=func_code, **context)
            generated_test = self._query_model(final_prompt)
            out_file.write_text(generated_test, encoding="utf-8")

            # Update kernel build metadata before compiling
            self._update_makefile(test_name)
            self._update_kconfig(test_name)
            self._update_test_config(test_name)

            if self._compile_and_check():
                print(f"‚úÖ Test '{test_name}' built successfully on attempt {attempt}.")
                return
            else:
                if self.error_log_file.exists():
                    context["error_logs"] = self.error_log_file.read_text(encoding="utf-8")
                print("üîÅ Retrying with compile error feedback...")

        print(f"‚ùå Failed to build a compilable test for {func_file_path.name} after {self.max_retries} attempts.")

    def run(self):
        print(f"--- Starting KUnit Test Generation in '{self.base_dir}' ---")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.error_log_file.parent.mkdir(parents=True, exist_ok=True)

        func_files = list(self.functions_dir.glob("*.c"))
        if not func_files:
            print(f"‚ùå No C files found in '{self.functions_dir}'")
            return

        for func_file in func_files:
            self.generate_test_for_function(func_file)

        print("\n--- ‚úÖ All tests processed. ---")

