import os
import subprocess
from pathlib import Path
from openai import OpenAI
from dotenv import load_dotenv

# Import your prompt template
from KunitGeneration.model_interface.prompts.unittest_kunit_prompts import kunit_generation_prompt


class KUnitTestGenerator:
    """
    A class to generate, compile, and validate KUnit tests for C functions.
    Automatically regenerates tests until compilation passes successfully.
    """

    def __init__(self, main_test_dir: Path, model_name: str, temperature: float, max_retries: int = 3):
        if not main_test_dir.is_dir():
            raise FileNotFoundError(f"The specified test directory does not exist: {main_test_dir}")

        # --- Paths ---
        self.base_dir = main_test_dir
        self.functions_dir = self.base_dir / "test_functions"
        self.output_dir = self.base_dir / "generated_tests"
        self.sample_files = [
            self.base_dir / "reference_testcases" / "kunit_test1.c",
            self.base_dir / "reference_testcases" / "kunit_test2.c",
            self.base_dir / "reference_testcases" / "kunit_test3.c",
        ]
        self.error_log_file = self.base_dir / "compilation_log" / "compile_error.txt"

        # --- Model ---
        self.model_name = model_name
        self.temperature = temperature
        self.max_tokens = 8192
        self.max_retries = max_retries

        # --- Setup ---
        self._load_environment()
        self.client = self._initialize_client()
        self.prompt_template = kunit_generation_prompt

    # ---------------- Environment Setup ----------------
    def _load_environment(self):
        load_dotenv()
        self.api_key = os.environ.get("NVIDIA_API_KEY")
        if not self.api_key:
            raise ValueError("NVIDIA_API_KEY environment variable not set.")

    def _initialize_client(self):
        return OpenAI(base_url="https://integrate.api.nvidia.com/v1", api_key=self.api_key)

    # ---------------- Model Query ----------------
    def _query_model(self, prompt: str) -> str:
        try:
            completion = self.client.chat.completions.create(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}],
                temperature=self.temperature,
                max_tokens=self.max_tokens,
            )
            return completion.choices[0].message.content
        except Exception as e:
            print(f"An error occurred while querying the model: {e}")
            return f"// Error generating response: {e}"

    # ---------------- Context Loader ----------------
    def _load_context_files(self) -> dict:
        print("Reading sample KUnit test files and error logs...")
        context = {}
        def safe_read(p: Path, fallback="// Missing file"): 
            return p.read_text(encoding="utf-8") if p.exists() else fallback

        context["sample_code1"] = safe_read(self.sample_files[0])
        context["sample_code2"] = safe_read(self.sample_files[1])
        context["sample_code3"] = safe_read(self.sample_files[2])
        context["error_logs"] = safe_read(self.error_log_file, "// No previous error logs")

        return context

    # ---------------- Kernel Build Integration ----------------
    def _update_makefile(self, test_name: str):
        makefile_path = self.base_dir / "Makefile"
        if not makefile_path.exists():
            print("‚ö†Ô∏è  No Makefile found ‚Äî skipping Makefile update.")
            return
        entry = f"obj-$(CONFIG_{test_name.upper()}) += {test_name}.o"
        text = makefile_path.read_text(encoding="utf-8")
        if entry not in text:
            with open(makefile_path, "a", encoding="utf-8") as f:
                f.write("\n" + entry + "\n")
            print(f"üß© Added to Makefile: {entry}")

    def _update_kconfig(self):
        """
        Inserts a custom Kconfig source entry before the line:
        source "drivers/pinctrl/actions/Kconfig"
        in /home/amd/linux/drivers/pinctrl/Kconfig.
        Creates a backup if not already made.
        """
        kconfig_path = Path("/home/amd/linux/drivers/pinctrl/Kconfig")
        backup_path = kconfig_path.with_suffix(".KunitGen_backup")
    
        # Ensure file exists
        if not kconfig_path.exists():
            print(f"‚ùå Kconfig not found at {kconfig_path}")
            return False
    
        # Backup before modifying (only once)
        if not backup_path.exists():
            backup_path.write_text(kconfig_path.read_text(encoding="utf-8"), encoding="utf-8")
            print(f"üì¶ Backup created: {backup_path}")
    
        # The new Kconfig include line you want to add
        new_line = 'source "drivers/pinctrl/my_pinctrl/Kconfig"'
    
        # Read lines
        lines = kconfig_path.read_text(encoding="utf-8").splitlines()
    
        # Skip if line already exists
        if any(new_line in line for line in lines):
            print("‚ÑπÔ∏è  Kconfig source already exists. Skipping insert.")
            return True
    
        updated_lines = []
        inserted = False
    
        for line in lines:
            # Insert our new source before actions/Kconfig
            if 'source "drivers/pinctrl/actions/Kconfig"' in line and not inserted:
                updated_lines.append(new_line)
                inserted = True
            updated_lines.append(line)
    
        # Save the updated file
        kconfig_path.write_text("\n".join(updated_lines) + "\n", encoding="utf-8")
    
        if inserted:
            print("‚úÖ Inserted new Kconfig source before 'actions/Kconfig'.")
        else:
            print("‚ö†Ô∏è  Target line not found. Appended entry at the end instead.")
            with open(kconfig_path, "a", encoding="utf-8") as f:
                f.write("\n" + new_line + "\n")
    
        return True

    def _update_test_config(self, test_name: str):
        cfg_path = self.base_dir / "my_pinctrl.config"
        if not cfg_path.exists():
            print("‚ö†Ô∏è  No my_pinctrl.config found ‚Äî skipping.")
            return
        config_line = f"CONFIG_{test_name.upper()}=y"
        cfg_text = cfg_path.read_text(encoding="utf-8")
        if config_line not in cfg_text:
            with open(cfg_path, "a", encoding="utf-8") as f:
                f.write("\n" + config_line + "\n")
            print(f"üß© Enabled {config_line} in my_pinctrl.config.")

    def _compile_kunit_test(self, test_name: str) -> bool:
        """Compile using kernel's KUnit infrastructure."""
        print(f"‚öôÔ∏è  Running KUnit compile for '{test_name}'...")
        cmd = (
            f"./tools/testing/kunit/kunit.py run "
            f"--kunitconfig=my_pinctrl.config "
            f"--arch=x86_64 --raw_output > {self.error_log_file} 2>&1"
        )
        result = subprocess.run(cmd, shell=True)
        log_text = self.error_log_file.read_text(encoding="utf-8") if self.error_log_file.exists() else ""

        if "error:" in log_text.lower() or result.returncode != 0:
            print(f"‚ùå Compilation failed for {test_name}. Check compile_error.txt.")
            return False
        print(f"‚úÖ Compilation passed for {test_name}.")
        return True

    # ---------------- Main Test Generation ----------------
    def generate_test_for_function(self, func_file_path: Path):
        func_code = func_file_path.read_text(encoding="utf-8")
        test_name = f"{func_file_path.stem}_kunit_test"
        out_file = self.output_dir / f"{test_name}.c"
        context = self._load_context_files()

        for attempt in range(1, self.max_retries + 1):
            print(f"\nüîπ Generating test for {func_file_path.name} (Attempt {attempt}/{self.max_retries})...")

            final_prompt = self.prompt_template.format(func_code=func_code, **context)
            generated_test = self._query_model(final_prompt)
            out_file.write_text(generated_test, encoding="utf-8")

            # Update kernel build metadata
            self._update_makefile(test_name)
            self._update_kconfig(test_name)
            self._update_test_config(test_name)

            # Run kernel compilation
            if self._compile_kunit_test(test_name):
                print(f"‚úÖ Test '{test_name}' built successfully on attempt {attempt}.")
                return
            else:
                # Feed back error logs to model
                if self.error_log_file.exists():
                    context["error_logs"] = self.error_log_file.read_text(encoding="utf-8")
                print("üîÅ Retrying with compile error feedback...")

        print(f"‚ùå Failed to build a compilable test for {func_file_path.name} after {self.max_retries} attempts.")

    def run(self):
        print(f"--- Starting KUnit Test Generation in '{self.base_dir}' ---")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.error_log_file.parent.mkdir(parents=True, exist_ok=True)

        func_files = list(self.functions_dir.glob("*.c"))
        if not func_files:
            print(f"‚ùå No C files found in '{self.functions_dir}'")
            return

        for func_file in func_files:
            self.generate_test_for_function(func_file)

        print("\n--- ‚úÖ All tests processed. ---")
